# hap小结

## 代码生成

### 代码生成器

- 启动hssp项目，访问代码生成器页面

  url地址：http://${host}:${port}/${context}/generator/generator.html

- 选择需要生成的对应位置的路径

  ![](E:\Hap培训\03-hap-dev-guide\images\1562137127366.png)
  - 项目路径：指定到当前的项目的根目录
  - 包父路径：指定到存放到当前功能包的上级路径
  - 包路径：指定存放controller、dto等包的父包，即当前功能包
  - 选择表：选择需要生成的在mysql数据库创建好的表

- 根据实际要求在第一个文件名前加功能号，点击其他位置时会自动触发应用到其他文件名确认框

### 代码调整

#### dto类

- 每个DTO都对应数据库中的一张表，需要继承 BaseDTO，BaseDTO 中封装了 who字段 以及 扩展字段

- DTO类上需要加如下注解

  - @ExtensionAttribute(disable=true)    ： 扩展字段注解   
  - @Table(name = "fnd_business_rule_b") ： 映射数据库表  
  - @Getter、@Setter、@AllArgsConstructor、@NoArgsConstructor、 @Builder、@ToString等 lombok注解   
  - @MultiLanguage  ： 若有多语言字段，则需要加多语言注解，对应的多语言表为 baseTable_tl

- DTO字段上需要加如下注解

  - 静态属性字段：
    - 每一个字段都需要添加其对应的静态属性字段
  - 主键字段需要加注解：
    - @Id              ： 主键注解
    - @GeneratedValue  ： 主键自增长注解。对于自增长、序列（SEQUENCE）类型的主键，需要添加注解
  - 多语言字段
    - 多语言字段需要添加多语言字段注解
    - @MultiLanguageField   ： 多语言字段注解
  - 字段类型
    - 不使用基本类型，全部使用基本类型的`包装类`，如 Long 对应数据库中的INTEGER，而不是使用 long
    - 数字类型主键统一采用 Long
    - 金额、数量 等精度严格浮点类型采用 BigDecimal。注意 BigDecimal 在计算、比较方面的特殊性
  - 条件查询字段
    - 若需要对某些字段进行条件查询，则需要加 @Where 声明该字段可以被条件查询，并在Controller中配合 Criteria 使用

  - 非数据库字段

    - @Transient：若存在与其他表的关联，指定字段不是持久性的。 

      

```java
package com.hand.hssp.gld.dto;

/**
 * Auto Generated By Hap Code Generator
 **/

import com.hand.hap.mybatis.annotation.ExtensionAttribute;
import com.hand.hap.mybatis.common.query.JoinColumn;
import com.hand.hap.mybatis.common.query.JoinOn;
import com.hand.hap.mybatis.common.query.JoinTable;
import com.hand.hap.mybatis.common.query.Where;
import com.hand.hap.system.dto.BaseDTO;
import lombok.*;
import org.hibernate.validator.constraints.Length;
import org.hibernate.validator.constraints.NotEmpty;

import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.Table;
import javax.persistence.Transient;
import javax.persistence.criteria.JoinType;
import javax.validation.constraints.NotNull;

/**
 * <p>
 * 核算主体级责任中心层级
 * </p>
 *
 * @author rui.shi@hand-china.com 2019/01/08 13:50
 */

@ExtensionAttribute(disable = true)
@Table(name = "gld_resp_center_hierarchy")
@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
@Builder
@ToString
public class GldRespCenterHierarchy extends BaseDTO {

    public static final String FIELD_HIERARCHY_ID = "hierarchyId";
    public static final String FIELD_PARENT_RESP_CENTER_ID = "parentRespCenterId";
    public static final String FIELD_RESPONSIBILITY_CENTER_ID = "responsibilityCenterId";
    public static final String FIELD_START_PERIOD_NAME = "startPeriodName";
    public static final String FIELD_END_PERIOD_NAME = "endPeriodName";
	public static final String FIELD_RESPONSIBILITY_CENTER_CODE = "responsibilityCenterCode";
	public static final String FIELD_RESPONSIBILITY_CENTER_NAME = "responsibilityCenterName";

    @Id
    @GeneratedValue
    private Long hierarchyId;

    /**
     * 父责任中心ID
     */
    @NotNull
	@JoinTable(name = "respCenterJoin", joinMultiLanguageTable = true, target = GldResponsibilityCenters24751.class,
			type = JoinType.LEFT, on = {@JoinOn(joinField = GldResponsibilityCenters24751.FIELD_RESPONSIBILITY_CENTER_ID)})
	@Where
    private Long parentRespCenterId;

    /**
     * 子责任中心ID
     */
    @NotNull
    private Long responsibilityCenterId;

    /**
     * 启用期间
     */
    @NotEmpty
    @Length(max = 30)
    private String startPeriodName;
    
    /**
     * 关闭期间
     */
    @Length(max = 30)
    private String endPeriodName;



    @Transient
	@JoinColumn(joinName = "respCenterJoin", field = GldResponsibilityCenters24751.FIELD_RESPONSIBILITY_CENTER_CODE)
	@Where
	private String responsibilityCenterCode;

    @Transient
	@JoinColumn(joinName = "respCenterJoin", field = GldResponsibilityCenters24751.FIELD_RESPONSIBILITY_CENTER_NAME)
	@Where
	private String responsibilityCenterName;
}
```

#### 其他

继承相应的Base类，提供单表基本crud操作。

## screen页面

### 一般小结

1. 获取数据由原来的${name}变为$[name]
2. 结果集model属性不再，改为baseUrl,queryUrl与submitUrl。分别指定对应的控制器根映射与相关操作映射。如果未指定queryUrl与submitUrl，框架将根据baseUrl自动拼接相关url，具体工具类：DatasetInit
3. 页面初始化查询需要通过controller层方法返回ModelAndView类型。

```java
@RequestMapping(value = "/gld/GLD2031/gld_responsibility_center.screen")
    public ModelAndView gldResponsibilityCenter(HttpServletRequest request) {
        IRequest requestContext = createRequestContext(request);
        GldAccountingEntity defaultAccEntity = gldAccountingEntityService.queryDefaultAccEntity(requestContext,requestContext.getCompanyId());
        List<GldAccountingEntity> gldAccountingEntityList = gldAccountingEntityService.queryAccEntityByCompany(requestContext,requestContext.getCompanyId());

        ModelAndView view = new ModelAndView("gld/GLD2031/gld_responsibility_center");
        view.addObject("gldAccountingEntityList", gldAccountingEntityList);
        view.addObject("defaultAccEntity", defaultAccEntity);
        return view;
    }
```

页面设置查询下拉框的值

```xml
<a:dataSet id="GLD2031_accEntityDs">
     <a:datas dataSource="gldAccountingEntityList/records"/>
</a:dataSet>

<a:dataSet>
    <a:field name="accEntityNameDisplay" defaultValue="$[/model/defaultAccEntity/records/record/@accEntityName]" displayField="accEntityName" options="GLD2031_accEntityDs" prompt="gld_accounting_entities.acc_entity_name_display" required="true" returnField="accEntityId" valueField="accEntityId"/>
</a:dataSet>
```

或

```xml
<a:dataSet id="FND2140_gldCoaStructureDs" autoQuery="true" fetchAll="true" baseUrl="/gld-coa-structure" queryUrl="$[/request/@context_path]/gld-coa-structure/query">
                <a:fields>
                    <a:field name="coaStructureCode"/>
                    <a:field name="coaStructureId"/>
                    <a:field name="structureFormat"/>
                    <a:field name="description"/>
                </a:fields>
            </a:dataSet>
```

映射到相应的字段上

```xml
<a:field name="coaStructureCode" displayField="coaStructureCode" options="FND2140_gldCoaStructureDs" required="true"   valueField="coaStructureId" returnField="coaStructureId" prompt="GLD_COA_STRUCTURE.COA_STRUCTURE_CODE">
       <a:mapping>
           <a:map from="coaStructureId" to="coaStructureId"/>
           <a:map from="coaStructureCode" to="coaStructureCode"/>
           <a:map from="description" to="coaDescription"/>
           <a:map from="structureFormat" to="coaStructureFormat"/>
       </a:mapping>
 </a:field>
```



页面获取默认初始值

```xml
<a:field name="accEntityId" defaultValue="$[/model/defaultAccEntity/records/record/@accEntityId]"  />
```

4. 页面字段需要使用驼峰命名规则，与后台实体类命名一致

5. 多语言字段相关配置

```java
@MultiLanguage
public class GldResponsibilityCenter extends BaseDTO {
   
   /**
     * 责任中心名称
     */
    @Length(max = 500)
    @MultiLanguageField
    @Where
    private String responsibilityCenterName;

}
```

实体类需要添加@MultiLanguageField注解

```xml
 <a:field name="responsibilityCenterName" required="true" prompt="gld_responsibility_center.responsibility_center_name" dto="com.hand.hssp.gld.dto.GldResponsibilityCenter" dtoId="responsibilityCenterId"/>
```

页面字段需要添加dto与dto主键字段

```xml
<a:grid id="GLD2030_responsibilityCentersGrid" bindTarget="GLD2030_responsibilityCentersResultDs" marginHeight="115" marginWidth="3" navBar="true">
            <a:columns>

                <a:column name="responsibilityCenterName" align="left" editor="GLD2030_responsibilityCenterNameTld" width="200"/>
               
            </a:columns>
            <a:editors>
                <a:tledit id="GLD2030_responsibilityCenterNameTld"/>
            </a:editors>
```

grid绑定数据集时，需要指定的编辑组件为<a:tledit />

6. sysCode的相关操作

数据来源添加在框架的`代码维护`页面

页面dataSet标签的绑定

```xml
<a:dataSet id="GLD2030_respCenterTypeCodeDs" autoQuery="true" fetchAll="true"  queryUrl="$[/request/@context_path]/common/auroraCode/GLD.RESP_CENTER_TYPE/"/>
```

与查询集绑定使用

```xml
<a:field name="respCenterTypeCodeDisplay" displayField="meaning" options="GLD2030_respCenterTypeCodeDs" prompt="gld_responsibility_center.resp_center_type_code_display" required="true" valueField="value" returnField="respCenterTypeCode" />
```

7. 日期需要精确到时分秒，否则后台将无法接受，所以需要使用`renderer="Aurora.formatDateTime"`渲染函数，编辑组件使用`<a:dateTimePicker id="GLD2030_grid_dp"/>`
8. comboBox事件

```xml
<a:comboBox name="magOrgName" bindTarget="CSH1075_query_ds" prompt="exp_mo_req_type.mag_org_id" width="170">
      <a:events>
            <a:event name="focus" handler="CSH1075_focus"/>
      </a:events>
</a:comboBox>
```

9. 动态编辑组件的运用

js函数

```js
function CSH1075_cashFlowItemTypeIdEdit(record, name) {
            if (record.isNew) {
                return 'CSH1075_cashFlow_lov';
            }
            return '';
        }
```

组件绑定

```xml
<a:column name="cashFlowItemDesc" editorFunction="CSH1075_cashFlowItemTypeIdEdit" prompt="csh_mo_pay_usd_ref_flow_it.cash_flow_item_id" width="250"/>

<a:lov id="CSH1075_cashFlow_lov"/>
```



### Lov框相关

1. lov定义

![](E:\Hap培训\03-hap-dev-guide\images\57157ae5d05b81c777a59a0b5316083.png)

2. 页面使用

字段中使用

通过`lovCode`指定需要使用的lov的名称

通过`from`指定lov框数据

通过`to`指定映射到页面的数据

```xml
<a:field name="bgtEntityName" lovCode="LOV_BGT_ENTITY_24751?accEntityId=$[/parameter/@accEntityId]" autoComplete="true" required="true" prompt="bgt_entity.description" title="bgt_entity.bgt_entity">
    <a:mapping>
        <a:map from="entityId" to="bgtEntityId"/>
        <a:map from="description" to="bgtEntityName"/>
    </a:mapping>
</a:field>
```

grid中使用部分代码

```xml
<a:column name="bgtEntityName" align="center" editor="GLD2030_accEntityRefLov" width="200"/>
<a:editors>
    <a:lov id="GLD2030_accEntityRefLov"/>
 </a:editors>
```

3. lov字段带出

当存在需求需要页面展示与lov相关联的数据时

给实体类添加`@JoinTable` 、 `@JoinColumn` 注解

`@JoinTable`注解指定需要关联的表与关联条件

 `@JoinColumn`指定要关联查询的字段

```java
 /**
     * 父责任中心ID
     */
    @NotNull
	@JoinTable(name = "respCenterJoin", joinMultiLanguageTable = true, target = GldResponsibilityCenters24751.class,
			type = JoinType.LEFT, on = {@JoinOn(joinField = GldResponsibilityCenters24751.FIELD_RESPONSIBILITY_CENTER_ID)})
	@Where
    private Long parentRespCenterId;

    @Transient
	@JoinColumn(joinName = "respCenterJoin", field = GldResponsibilityCenters24751.FIELD_RESPONSIBILITY_CENTER_CODE)
	@Where
	private String responsibilityCenterCode;

    @Transient
	@JoinColumn(joinName = "respCenterJoin", field = GldResponsibilityCenters24751.FIELD_RESPONSIBILITY_CENTER_NAME)
	@Where
	private String responsibilityCenterName;
```

在controller层使用Criteria类，与selectOptions()方法配合查询，如下

```java
@RequestMapping("/query")
    @ResponseBody
    public ResponseData query(GldRespCenterHierarchy dto, @RequestParam(defaultValue = DEFAULT_PAGE) int page,
        @RequestParam(defaultValue = DEFAULT_PAGE_SIZE) int pageSize, HttpServletRequest request) {
        IRequest requestContext = createRequestContext(request);

		Criteria criteria = new Criteria(dto);
		criteria.where(new WhereField(GldRespCenterHierarchy.FIELD_PARENT_RESP_CENTER_ID),
				new WhereField(GldRespCenterHierarchy.FIELD_RESPONSIBILITY_CENTER_CODE),
				new WhereField(GldRespCenterHierarchy.FIELD_RESPONSIBILITY_CENTER_NAME));

        return new ResponseData(service.selectOptions(requestContext,dto,criteria,page,pageSize));
    }
```

4. 传参

字符串拼接传参，sql直接使用`#{accEntityId} `进行接收

直接在lovCode拼接参数，多参数使用`&amp;`进行分隔

```xml
<a:field name="responsibilityCenterCode" lovCode="LOV_GLD_RESPONSIBILITY_CENTER?accEntityId=$[/parameter/@accEntityId]&amp;parentRespCenterId=$[/parameter/@parentRespCenterId]" autoComplete="true" required="true" prompt="gld_responsibility_center.responsibility_center_code" title="gld_responsibility_center.responsibility_center_code">
                        <a:mapping>
                            <a:map from="responsibilityCenterId" to="responsibilityCenterId"/>
                            <a:map from="responsibilityCenterCode" to="responsibilityCenterCode"/>
                            <a:map from="responsibilityCenterName" to="responsibilityCenterName"/>
                        </a:mapping>
                    </a:field>
```

使用js进行传参,参考页面`bgt_budget_balance_query.screen`

```js
record.getMeta().getField('parameterValueCode').setLovPara('bgtOrgId', bgtOrgId);                record.getMeta().getField('parameterValueCode').setLovPara('companyId', companyId);                record.getMeta().getField('parameterValueCode').setLovPara('parameterCode', parameterCode);                record.getMeta().getField('parameterValueCode').setTitle(record.get('parameterName'));
```

5. lov自定义SQL示例

```sql
SELECT
    be.entity_id,
    be.entity_code,
    betl.description  
FROM
    bgt_entity be
    join bgt_entity_tl  betl on be.ENTITY_ID =betl.ENTITY_ID 
    and betl.LANG =  #{request.locale,jdbcType=VARCHAR,javaType=java.lang.String}
    AND be.enabled_flag = 'Y'
    and EXISTS (
            SELECT
                1 
            FROM
                gld_acc_entity_ref_be a 
            WHERE
                a.bgt_entity_id = be.entity_id 
                AND a.acc_entity_id = #{accEntityId} 
                AND a.enabled_flag = 'Y' 
    ) 
    <if test="entityCode != null">
        AND be.entity_code LIKE CONCAT('%',#{entityCode},'%')
    </if>
    <if test="description != null">
        AND be.description LIKE CONCAT('%',#{description},'%')
    </if>
```



## controller

### 继承

需要继承 BaseController ，这样就有了一些通用方法，请求参数验证、异常处理

### 相关工具类

#### IRequest类

将前台传入后台的一些session数据封装入IRequest对象，传入service层进行其他操作

```java
IRequest requestContext = createRequestContext(request);
```

#### ResponseData类

查询数据封装类，将数据数量，查询信息，查询得到的数据等传回到请求页面

使用

```java
public ResponseData update(@RequestBody List<CshMoPaymentUsedTest> dto, BindingResult result, HttpServletRequest request){
        getValidator().validate(dto, result);
        if (result.hasErrors()) {
        ResponseData responseData = new ResponseData(false);
        responseData.setMessage(getErrorMessage(result, request));
        return responseData;
        }
        IRequest requestCtx = createRequestContext(request);
        return new ResponseData(service.batchUpdate(requestCtx, dto));
    }
```

部分源码

```java
public class ResponseData {

    // 返回状态编码
    @JsonInclude(Include.NON_NULL)
    private String code;

    // 返回信息
    @JsonInclude(Include.NON_NULL)
    private String message;

    //数据
    @JsonInclude(Include.NON_NULL)
    private List<?> rows;

    // 成功标识
    private boolean success = true;

    //总数
    @JsonInclude(Include.NON_NULL)
    private Long total;
```

#### HttpServletRequest类

HttpServletRequest对象代表客户端的请求，当客户端通过HTTP协议访问服务器时，HTTP**请求头**中的所有信息都封装在这个对象中，通过这个对象提供的方法，可以获得客户端请求的所有信息。

具体方法参考<https://blog.csdn.net/jiahao1186/article/details/82026330>

#### Criteria类

封装拓展查询字段，查询条件字段等.暂时使用情况用于查询数据时需要带出另一张表中的某几个字段数据。查询需要与selectOptions进行配套使用。拼接sql需要使用工具类`SqlHelper`

`关联表数量过多时尽量自己写查询sql`

```java
public ResponseData query(CshMoPayUsdRefFlowIt dto, @RequestParam(defaultValue = DEFAULT_PAGE) int page,
        @RequestParam(defaultValue = DEFAULT_PAGE_SIZE) int pageSize, HttpServletRequest request) {
        IRequest requestContext = createRequestContext(request);
        Criteria criteria = new Criteria(dto);
        criteria.where(new WhereField(CshMoPayUsdRefFlowIt.FIELD_PAYMENT_USEDE_ID, Comparison.EQUAL),
                new WhereField(CshMoPayUsdRefFlowIt.FIELD_PAYMENT_USEDE_CODE, Comparison.LIKE),
                new WhereField(CshMoPayUsdRefFlowIt.FIELD_CASH_FLOW_ITEM_DESC, Comparison.LIKE),
                new WhereField(CshMoPayUsdRefFlowIt.FIELD_SET_OF_BOOKS_NAME, Comparison.LIKE));
        return new ResponseData(service.selectOptions(requestContext,dto,criteria,page,pageSize));

    }
```

与其配套使用的有`@Where `、` @JoinTable`  、`@JoinClolumn` 注解

@Where注解指定可以作为查询条件的字段

@JoinTable注解指定需要关联查询的表与连接条件

@JoinClolumn注解指定需要关联查询的字段

```java
@JoinTable(name = "respCenterJoin", joinMultiLanguageTable = true, target = GldResponsibilityCenters24751.class,
			type = JoinType.LEFT, on = {@JoinOn(joinField = GldResponsibilityCenters24751.FIELD_RESPONSIBILITY_CENTER_ID)})
	@Where
    private Long parentRespCenterId;

    @Transient
	@JoinColumn(joinName = "respCenterJoin", field = GldResponsibilityCenters24751.FIELD_RESPONSIBILITY_CENTER_CODE)
	@Where
	private String responsibilityCenterCode;

    @Transient
	@JoinColumn(joinName = "respCenterJoin", field = GldResponsibilityCenters24751.FIELD_RESPONSIBILITY_CENTER_NAME)
	@Where
	private String responsibilityCenterName;
```

## service

### 继承

service 接口 需要继承IBaseServcie 和 ProxySelf 这两个接口：

- IBaseServcie 提供了基本的增删改查接口。 
- ProxySelf 提供了自身代理功能

### 处理IRequest对象

项目存在一个切面，拦截所有 Service 方法执行,处理与 IRequest 相关的参数。

因此在mapper.java不需要传入IRequest对象，但是mapper.xml中可直接使用request.具体字段获得需要的数据

```xml
 <bean id="requestAD" class="com.hand.hap.core.impl.ServiceExecutionAdvice"/>

    <aop:config expose-proxy="true">
        <aop:pointcut id="servicePointcut" expression="execution(* *..*ServiceImpl.*(..))"/>
        <aop:advisor advice-ref="requestAD" pointcut-ref="servicePointcut"/>
    </aop:config>
```

### 分页

通过`PageHelper.startPage(pageNum, pageSize);`方法进行分页

```java
@Override
	public List<FndAtmAttachment> queryFndAtmAttachment(IRequest request, FndAtmAttachment dto, int pageNum,
			int pageSize) {
		PageHelper.startPage(pageNum, pageSize);
		return self().queryFndAtmAttachment(request, dto);
	}
```

## 头行联动

头行联动需要用到一个核心事件

![1566351043153](C:\Users\fengjirong\AppData\Roaming\Typora\typora-user-images\1566351043153.png)

此事件绑定于头dataSet数据集，其相关代码如下

其中if条件判断头结构是否为新增的一行头数据，如果是一行头数据，则给从表查询添加过滤条件，置空；否则按照选中行获取对应的从表数据。

其中设置全局变量的作用是用于行表add事件的数据渲染

```js
function CSH1075_headIndexChange(ds,record) {
                $au('btnAdd').enable();
                $au('btnSave').enable();
                glb_usedes_id = record.get("paymentUsedeId");
                glb_usedes_code = record.get("paymentUsedeCode");
                var usedes_id = record.get("paymentUsedeId");
                if (usedes_id==null||usedes_id==undefined){
                    $au("CSH1075_line_ds").setQueryParameter('paymentUsedeId', -1);
                    $au("CSH1075_line_ds").query();
                }else{
                    $au("CSH1075_line_ds").setQueryParameter('paymentUsedeId', glb_usedes_id);
                    $au("CSH1075_line_ds").query();
                }
            }
```

保存时，其分解并不是按照aurora框架的行表绑定主表的形式。本框架头数据为新增状态时不支持同时添加头与行，头结构id渲染到行表时需要先对头结构进行保存，再通过查询带回，再通过行表的add事件进行相应的绑定，最后再提交行表数据。

```js
function CSH1075_addFunction(ds, record, index) {
            record.set('paymentUsedeCode', glb_usedes_code);
            record.set('paymentUsedeId', glb_usedes_id);
        }
```

